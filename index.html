<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Latency Monitor</title>
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
			background: #0a0a0f;
			color: #e0e0e0;
			min-height: 100vh;
			padding: 20px;
		}

		.container {
			width: 100%;
			margin: 0 auto;
		}

		h1 {
			font-size: 1.5rem;
			font-weight: 400;
			margin-bottom: 20px;
			color: #8af;
		}

		.stats {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 15px;
			margin-bottom: 20px;
		}

		.stat-box {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			text-align: center;
		}

		.stat-label {
			font-size: 0.75rem;
			color: #888;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			margin-bottom: 5px;
		}

		.stat-value {
			font-size: 1.5rem;
			font-weight: 600;
			font-family: 'SF Mono', Monaco, monospace;
		}

		.stat-value.current {
			color: #4f8;
		}

		.stat-value.min {
			color: #4df;
		}

		.stat-value.max {
			color: #f84;
		}

		.stat-value.avg {
			color: #fa4;
		}

		.stat-value.jitter {
			color: #c8f;
		}

		.stat-value.loss {
			color: #f44;
		}

		.controls {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
			flex-wrap: wrap;
			align-items: center;
		}

		.controls label {
			font-size: 0.85rem;
			color: #888;
		}

		.controls select {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 4px;
			padding: 8px 12px;
			color: #e0e0e0;
			font-size: 0.9rem;
		}

		.controls select:focus {
			outline: none;
			border-color: #4af;
		}

		button {
			background: #2a4;
			border: none;
			border-radius: 4px;
			padding: 8px 20px;
			color: white;
			font-size: 0.9rem;
			cursor: pointer;
			transition: background 0.2s;
		}

		button:hover {
			background: #3b5;
		}

		button.stop {
			background: #a33;
		}

		button.stop:hover {
			background: #c44;
		}

		button.clear {
			background: #555;
		}

		button.clear:hover {
			background: #666;
		}

		.graph-container {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			margin-bottom: 20px;
		}

		canvas {
			width: 100%;
			height: 200px;
			display: block;
		}

		.log {
			background: #0d0d12;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 10px;
			max-height: 200px;
			overflow-y: auto;
			font-family: 'SF Mono', Monaco, monospace;
			font-size: 0.8rem;
		}

		.log-entry {
			padding: 3px 0;
			border-bottom: 1px solid #1a1a25;
		}

		.log-entry:last-child {
			border-bottom: none;
		}

		.log-time {
			color: #666;
		}

		.log-ok {
			color: #4f8;
		}

		.log-slow {
			color: #fa4;
		}

		.log-fail {
			color: #f44;
		}

		.status {
			display: inline-block;
			width: 10px;
			height: 10px;
			border-radius: 50%;
			margin-right: 10px;
			background: #444;
		}

		.status.running {
			background: #4f8;
			animation: pulse 1s infinite;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}
		}

		.header {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 20px;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<span class="status" id="status"></span>
			<h1>Latency Monitor</h1>
		</div>
		<div class="controls">
			<label>Target:</label>
			<select id="target">
				<option value="https://www.google.com/favicon.ico">Google</option>
				<option value="https://www.cloudflare.com/favicon.ico">Cloudflare</option>
				<option value="https://www.amazon.com/favicon.ico">Amazon</option>
				<option value="https://github.githubassets.com/favicons/favicon.svg">GitHub</option>
				<option value="https://www.apple.com/favicon.ico">Apple</option>
			</select>
			<label>Interval:</label>
			<select id="interval">
				<option value="500">500ms</option>
				<option value="1000" selected>1s</option>
				<option value="2000">2s</option>
				<option value="5000">5s</option>
			</select>
			<button id="toggleBtn" onclick="toggle()">Start</button>
			<button class="clear" onclick="clearData()">Clear</button>
		</div>
		<div class="stats">
			<div class="stat-box">
				<div class="stat-label">Current</div>
				<div class="stat-value current" id="current">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Min</div>
				<div class="stat-value min" id="min">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Max</div>
				<div class="stat-value max" id="max">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Avg</div>
				<div class="stat-value avg" id="avg">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Jitter</div>
				<div class="stat-value jitter" id="jitter">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Loss</div>
				<div class="stat-value loss" id="loss">0%</div>
			</div>
		</div>
		<div class="graph-container">
			<canvas id="graph"></canvas>
		</div>
		<div class="log" id="log"></div>
	</div>
	<script>
		const state = {
			running: false,
			intervalId: null,
			samples: [],
			failures: 0,
			total: 0,
			maxSamples: 100
		};

		const canvas = document.getElementById('graph');
		const ctx = canvas.getContext('2d');

		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			canvas.width = rect.width * window.devicePixelRatio;
			canvas.height = rect.height * window.devicePixelRatio;
			ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
			drawGraph();
		}

		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		function ping() {
			const url = document.getElementById('target').value;
			const start = performance.now();
			state.total++;

			const img = new Image();
			let done = false;

			const timeout = setTimeout(() => {
				if (done) return;
				done = true;
				state.failures++;
				updateStats(null);
				addLog(null, false);
				drawGraph();
			}, 5000);

			function handleResponse() {
				if (done) return;
				done = true;
				clearTimeout(timeout);
				const latency = Math.round(performance.now() - start);
				recordSuccess(latency);
			}

			img.onload = handleResponse;
			img.onerror = handleResponse; // onerror still means network responded

			img.src = url + '?_=' + Date.now() + Math.random();
		}

		function recordSuccess(latency) {
			state.samples.push(latency);
			if (state.samples.length > state.maxSamples) state.samples.shift();
			updateStats(latency);
			addLog(latency, true);
			drawGraph();
		}

		function updateStats(latency) {
			if (latency !== null) {
				document.getElementById('current').textContent = latency + 'ms';
			}

			if (state.samples.length > 0) {
				const min = Math.min(...state.samples);
				const max = Math.max(...state.samples);
				const avg = Math.round(state.samples.reduce((a, b) => a + b, 0) / state.samples.length);

				document.getElementById('min').textContent = min + 'ms';
				document.getElementById('max').textContent = max + 'ms';
				document.getElementById('avg').textContent = avg + 'ms';

				if (state.samples.length > 1) {
					const variance = state.samples.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / state.samples.length;
					document.getElementById('jitter').textContent = Math.round(Math.sqrt(variance)) + 'ms';
				}
			}

			const lossPercent = state.total > 0 ? Math.round((state.failures / state.total) * 100) : 0;
			document.getElementById('loss').textContent = lossPercent + '%';
		}

		function addLog(latency, success) {
			const log = document.getElementById('log');
			const time = new Date().toLocaleTimeString();
			const target = document.getElementById('target').selectedOptions[0].text;
			const entry = document.createElement('div');
			entry.className = 'log-entry';

			if (success) {
				const cls = latency < 100 ? 'log-ok' : (latency < 300 ? 'log-slow' : 'log-fail');
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="${cls}">${latency}ms</span>`;
			} else {
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="log-fail">TIMEOUT</span>`;
			}

			log.insertBefore(entry, log.firstChild);
			while (log.children.length > 50) log.removeChild(log.lastChild);
		}

		function drawGraph() {
			const w = canvas.width / window.devicePixelRatio;
			const h = canvas.height / window.devicePixelRatio;

			ctx.fillStyle = '#151520';
			ctx.fillRect(0, 0, w, h);

			if (state.samples.length < 2) return;

			const maxVal = Math.max(...state.samples, 100);
			const padding = 10;
			const graphW = w - padding * 2;
			const graphH = h - padding * 2;

			// Grid
			ctx.strokeStyle = '#252535';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = padding + (graphH / 4) * i;
				ctx.beginPath();
				ctx.moveTo(padding, y);
				ctx.lineTo(w - padding, y);
				ctx.stroke();
			}

			// Fill under line
			ctx.fillStyle = 'rgba(68, 255, 136, 0.1)';
			ctx.beginPath();
			ctx.moveTo(padding, h - padding);

			state.samples.forEach((sample, i) => {
				const x = padding + (i / (state.maxSamples - 1)) * graphW;
				const y = padding + graphH - (sample / maxVal) * graphH;
				ctx.lineTo(x, y);
			});

			ctx.lineTo(padding + ((state.samples.length - 1) / (state.maxSamples - 1)) * graphW, h - padding);
			ctx.closePath();
			ctx.fill();

			// Line
			ctx.strokeStyle = '#4f8';
			ctx.lineWidth = 2;
			ctx.beginPath();

			state.samples.forEach((sample, i) => {
				const x = padding + (i / (state.maxSamples - 1)) * graphW;
				const y = padding + graphH - (sample / maxVal) * graphH;
				i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
			});
			ctx.stroke();

			// Current point
			if (state.samples.length > 0) {
				const last = state.samples[state.samples.length - 1];
				const x = padding + ((state.samples.length - 1) / (state.maxSamples - 1)) * graphW;
				const y = padding + graphH - (last / maxVal) * graphH;
				ctx.fillStyle = '#4f8';
				ctx.beginPath();
				ctx.arc(x, y, 5, 0, Math.PI * 2);
				ctx.fill();
			}

			// Scale labels
			ctx.fillStyle = '#666';
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			ctx.fillText(maxVal + 'ms', w - padding, padding + 10);
			ctx.fillText('0ms', w - padding, h - padding);
		}

		function toggle() {
			const btn = document.getElementById('toggleBtn');
			const status = document.getElementById('status');

			if (state.running) {
				clearInterval(state.intervalId);
				state.running = false;
				btn.textContent = 'Start';
				btn.classList.remove('stop');
				status.classList.remove('running');
			} else {
				const interval = parseInt(document.getElementById('interval').value);
				ping();
				state.intervalId = setInterval(ping, interval);
				state.running = true;
				btn.textContent = 'Stop';
				btn.classList.add('stop');
				status.classList.add('running');
			}
		}

		function clearData() {
			state.samples = [];
			state.failures = 0;
			state.total = 0;
			['current', 'min', 'max', 'avg', 'jitter'].forEach(id =>
				document.getElementById(id).textContent = '--');
			document.getElementById('loss').textContent = '0%';
			document.getElementById('log').innerHTML = '';
			drawGraph();
		}
	</script>
</body>

</html>
