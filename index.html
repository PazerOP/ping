<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Latency Monitor</title>
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
			background: #0a0a0f;
			color: #e0e0e0;
			min-height: 100vh;
			padding: 20px;
			zoom: 1.25;
		}

		.container {
			width: 100%;
			margin: 0 auto;
		}

		h1 {
			font-size: 1.5rem;
			font-weight: 400;
			margin-bottom: 20px;
			color: #8af;
		}

		.stats {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 15px;
			margin-bottom: 20px;
		}

		.stat-box {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			text-align: center;
		}

		.stat-label {
			font-size: 0.75rem;
			color: #888;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			margin-bottom: 5px;
		}

		.stat-value {
			font-size: 1.5rem;
			font-weight: 600;
			font-family: 'SF Mono', Monaco, monospace;
		}

		.stat-value.current {
			color: #4f8;
		}

		.stat-value.min {
			color: #4df;
		}

		.stat-value.max {
			color: #f84;
		}

		.stat-value.avg {
			color: #fa4;
		}

		.stat-value.jitter {
			color: #c8f;
		}

		.stat-value.loss {
			color: #f44;
		}

		.controls {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
			flex-wrap: wrap;
			align-items: center;
		}

		.controls label {
			font-size: 0.85rem;
			color: #888;
		}

		.controls select {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 4px;
			padding: 8px 12px;
			color: #e0e0e0;
			font-size: 0.9rem;
		}

		.controls select:focus {
			outline: none;
			border-color: #4af;
		}

		button {
			background: #2a4;
			border: none;
			border-radius: 4px;
			padding: 8px 20px;
			color: white;
			font-size: 0.9rem;
			cursor: pointer;
			transition: background 0.2s;
		}

		button:hover {
			background: #3b5;
		}

		button.stop {
			background: #a33;
		}

		button.stop:hover {
			background: #c44;
		}

		button.clear {
			background: #555;
		}

		button.clear:hover {
			background: #666;
		}

		.graph-container {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			margin-bottom: 20px;
		}

		canvas {
			width: 100%;
			height: 200px;
			display: block;
		}

		.log {
			background: #0d0d12;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 10px;
			max-height: 200px;
			overflow-y: auto;
			font-family: 'SF Mono', Monaco, monospace;
			font-size: 0.8rem;
		}

		.log-entry {
			padding: 3px 0;
			border-bottom: 1px solid #1a1a25;
		}

		.log-entry:last-child {
			border-bottom: none;
		}

		.log-time {
			color: #666;
		}

		.log-ok {
			color: #4f8;
		}

		.log-slow {
			color: #fa4;
		}

		.log-fail {
			color: #f44;
		}

		.status {
			display: inline-block;
			width: 10px;
			height: 10px;
			border-radius: 50%;
			margin-right: 10px;
			background: #444;
		}

		.status.running {
			background: #4f8;
			animation: pulse 1s infinite;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}
		}

		.header {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 20px;
		}

		.header-links {
			margin-left: auto;
			display: flex;
			gap: 15px;
		}

		.header-links a {
			color: #888;
			text-decoration: none;
			font-size: 0.85rem;
			transition: color 0.2s;
		}

		.header-links a:hover {
			color: #8af;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<span class="status" id="status"></span>
			<h1>Latency Monitor</h1>
			<div class="header-links">
				<a href="https://github.com/PazerOP/ping" target="_blank">GitHub</a>
				<a href="https://claude.ai/code" target="_blank">Claude Code</a>
			</div>
		</div>
		<div class="controls">
			<label>Target:</label>
			<select id="target">
				<option value="https://www.google.com/favicon.ico">Google</option>
				<option value="https://www.cloudflare.com/favicon.ico">Cloudflare</option>
				<option value="https://www.amazon.com/favicon.ico">Amazon</option>
				<option value="https://github.githubassets.com/favicons/favicon.svg">GitHub</option>
				<option value="https://www.apple.com/favicon.ico">Apple</option>
			</select>
			<label>Interval:</label>
			<select id="interval">
				<option value="500">500ms</option>
				<option value="1000" selected>1s</option>
				<option value="2000">2s</option>
				<option value="5000">5s</option>
			</select>
			<button id="toggleBtn" onclick="toggle()">Start</button>
			<button class="clear" onclick="clearData()">Clear</button>
		</div>
		<div class="stats">
			<div class="stat-box">
				<div class="stat-label">Current</div>
				<div class="stat-value current" id="current">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Min</div>
				<div class="stat-value min" id="min">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Max</div>
				<div class="stat-value max" id="max">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Avg</div>
				<div class="stat-value avg" id="avg">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Jitter</div>
				<div class="stat-value jitter" id="jitter">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Loss</div>
				<div class="stat-value loss" id="loss">0%</div>
			</div>
		</div>
		<div class="graph-container">
			<canvas id="graph"></canvas>
		</div>
		<div class="log" id="log"></div>
	</div>
	<script>
		const state = {
			running: false,
			intervalId: null,
			samples: [],
			displaySamples: [], // Animated samples for smooth rendering
			failures: 0,
			total: 0,
			maxSamples: 100,
			animationId: null,
			lastFrameTime: 0
		};

		const canvas = document.getElementById('graph');
		const ctx = canvas.getContext('2d');

		// Easing function for smooth animation
		function easeOutCubic(t) {
			return 1 - Math.pow(1 - t, 3);
		}

		// Linear interpolation
		function lerp(start, end, t) {
			return start + (end - start) * t;
		}

		// Animation loop for smooth graph updates
		function animate(currentTime) {
			if (!state.lastFrameTime) state.lastFrameTime = currentTime;
			const deltaTime = currentTime - state.lastFrameTime;
			state.lastFrameTime = currentTime;

			// Animation speed - how fast values converge (higher = faster)
			const animationSpeed = 0.15;
			let needsRedraw = false;

			// Sync displaySamples length with samples
			while (state.displaySamples.length < state.samples.length) {
				// New sample added - start from previous value or 0
				const prevVal = state.displaySamples.length > 0
					? state.displaySamples[state.displaySamples.length - 1]
					: (state.samples[state.displaySamples.length] || 0);
				state.displaySamples.push(prevVal);
				needsRedraw = true;
			}
			while (state.displaySamples.length > state.samples.length) {
				state.displaySamples.shift();
				needsRedraw = true;
			}

			// Animate each sample toward its target
			for (let i = 0; i < state.samples.length; i++) {
				const target = state.samples[i];
				const current = state.displaySamples[i];

				if (target === null) {
					state.displaySamples[i] = null;
				} else if (current === null) {
					state.displaySamples[i] = target;
					needsRedraw = true;
				} else if (Math.abs(target - current) > 0.5) {
					state.displaySamples[i] = lerp(current, target, animationSpeed);
					needsRedraw = true;
				} else {
					state.displaySamples[i] = target;
				}
			}

			if (needsRedraw) {
				drawGraph();
			}

			state.animationId = requestAnimationFrame(animate);
		}

		// Start animation loop
		state.animationId = requestAnimationFrame(animate);

		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			canvas.width = rect.width * window.devicePixelRatio;
			canvas.height = rect.height * window.devicePixelRatio;
			ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
			drawGraph();
		}

		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		function ping() {
			const url = document.getElementById('target').value;
			const start = performance.now();
			state.total++;

			const img = new Image();
			let done = false;

			const timeout = setTimeout(() => {
				if (done) return;
				done = true;
				state.failures++;
				state.samples.push(null); // Record loss as null
				if (state.samples.length > state.maxSamples) state.samples.shift();
				updateStats(null);
				addLog(null, false);
				drawGraph();
			}, 2000);

			function handleResponse() {
				if (done) return;
				done = true;
				clearTimeout(timeout);
				const latency = Math.round(performance.now() - start);
				recordSuccess(latency);
			}

			img.onload = handleResponse;
			img.onerror = handleResponse; // onerror still means network responded

			img.src = url + '?_=' + Date.now() + Math.random();
		}

		function recordSuccess(latency) {
			state.samples.push(latency);
			if (state.samples.length > state.maxSamples) state.samples.shift();
			updateStats(latency);
			addLog(latency, true);
			drawGraph();
		}

		function updateStats(latency) {
			if (latency !== null) {
				document.getElementById('current').textContent = latency + 'ms';
			}

			if (state.samples.length > 0) {
				const min = Math.min(...state.samples);
				const max = Math.max(...state.samples);
				const avg = Math.round(state.samples.reduce((a, b) => a + b, 0) / state.samples.length);

				document.getElementById('min').textContent = min + 'ms';
				document.getElementById('max').textContent = max + 'ms';
				document.getElementById('avg').textContent = avg + 'ms';

				if (state.samples.length > 1) {
					const variance = state.samples.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / state.samples.length;
					document.getElementById('jitter').textContent = Math.round(Math.sqrt(variance)) + 'ms';
				}
			}

			const lossPercent = state.total > 0 ? Math.round((state.failures / state.total) * 100) : 0;
			document.getElementById('loss').textContent = lossPercent + '%';
		}

		function addLog(latency, success) {
			const log = document.getElementById('log');
			const time = new Date().toLocaleTimeString();
			const target = document.getElementById('target').selectedOptions[0].text;
			const entry = document.createElement('div');
			entry.className = 'log-entry';

			if (success) {
				const cls = latency < 100 ? 'log-ok' : (latency < 300 ? 'log-slow' : 'log-fail');
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="${cls}">${latency}ms</span>`;
			} else {
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="log-fail">TIMEOUT</span>`;
			}

			log.insertBefore(entry, log.firstChild);
			while (log.children.length > 50) log.removeChild(log.lastChild);
		}

		function drawGraph() {
			const w = canvas.width / window.devicePixelRatio;
			const h = canvas.height / window.devicePixelRatio;

			ctx.fillStyle = '#151520';
			ctx.fillRect(0, 0, w, h);

			// Use displaySamples for smooth animation
			const samples = state.displaySamples;
			if (samples.length < 2) return;

			// Filter out nulls for maxVal calculation (use actual samples for consistent scale)
			const validSamples = state.samples.filter(s => s !== null);
			const maxVal = validSamples.length > 0 ? Math.max(...validSamples, 100) : 100;
			const padding = 10;
			const graphW = w - padding * 2;
			const graphH = h - padding * 2;

			// Grid
			ctx.strokeStyle = '#252535';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = padding + (graphH / 4) * i;
				ctx.beginPath();
				ctx.moveTo(padding, y);
				ctx.lineTo(w - padding, y);
				ctx.stroke();
			}

			// Fill under line (skip nulls) - with smooth curves
			ctx.fillStyle = 'rgba(68, 255, 136, 0.1)';
			let fillStarted = false;
			let lastValidX = padding;
			let points = [];
			samples.forEach((sample, i) => {
				const x = padding + (i / (state.maxSamples - 1)) * graphW;
				if (sample !== null) {
					const y = padding + graphH - (sample / maxVal) * graphH;
					points.push({ x, y });
				} else if (points.length > 0) {
					// Draw fill for this segment
					drawSmoothFill(points, h, padding);
					points = [];
				}
			});
			if (points.length > 0) {
				drawSmoothFill(points, h, padding);
			}

			// Line (break at nulls to create gaps) - with smooth curves
			ctx.strokeStyle = '#4f8';
			ctx.lineWidth = 2;
			points = [];
			samples.forEach((sample, i) => {
				const x = padding + (i / (state.maxSamples - 1)) * graphW;
				if (sample !== null) {
					const y = padding + graphH - (sample / maxVal) * graphH;
					points.push({ x, y });
				} else if (points.length > 0) {
					drawSmoothLine(points);
					points = [];
				}
			});
			if (points.length > 0) {
				drawSmoothLine(points);
			}

			// Draw red X marks for packet loss
			ctx.strokeStyle = '#f44';
			ctx.lineWidth = 2;
			state.samples.forEach((sample, i) => {
				if (sample === null) {
					const x = padding + (i / (state.maxSamples - 1)) * graphW;
					const y = h - padding - 10; // Near bottom
					ctx.beginPath();
					ctx.moveTo(x - 4, y - 4);
					ctx.lineTo(x + 4, y + 4);
					ctx.moveTo(x + 4, y - 4);
					ctx.lineTo(x - 4, y + 4);
					ctx.stroke();
				}
			});

			// Current point
			if (samples.length > 0) {
				const last = samples[samples.length - 1];
				const x = padding + ((samples.length - 1) / (state.maxSamples - 1)) * graphW;
				if (last !== null) {
					const y = padding + graphH - (last / maxVal) * graphH;
					ctx.fillStyle = '#4f8';
					ctx.beginPath();
					ctx.arc(x, y, 5, 0, Math.PI * 2);
					ctx.fill();
				} else {
					// Red dot for current loss
					ctx.fillStyle = '#f44';
					ctx.beginPath();
					ctx.arc(x, h - padding - 10, 5, 0, Math.PI * 2);
					ctx.fill();
				}
			}

			// Scale labels
			ctx.fillStyle = '#666';
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			ctx.fillText(maxVal + 'ms', w - padding, padding + 10);
			ctx.fillText('0ms', w - padding, h - padding);
		}

		// Draw smooth curved line through points
		function drawSmoothLine(points) {
			if (points.length < 2) return;

			ctx.beginPath();
			ctx.moveTo(points[0].x, points[0].y);

			if (points.length === 2) {
				ctx.lineTo(points[1].x, points[1].y);
			} else {
				// Use cardinal spline for smooth curves
				for (let i = 0; i < points.length - 1; i++) {
					const p0 = points[Math.max(0, i - 1)];
					const p1 = points[i];
					const p2 = points[i + 1];
					const p3 = points[Math.min(points.length - 1, i + 2)];

					// Control points for smooth curve
					const tension = 0.3;
					const cp1x = p1.x + (p2.x - p0.x) * tension;
					const cp1y = p1.y + (p2.y - p0.y) * tension;
					const cp2x = p2.x - (p3.x - p1.x) * tension;
					const cp2y = p2.y - (p3.y - p1.y) * tension;

					ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
				}
			}
			ctx.stroke();
		}

		// Draw smooth filled area under curve
		function drawSmoothFill(points, h, padding) {
			if (points.length < 2) return;

			ctx.beginPath();
			ctx.moveTo(points[0].x, h - padding);
			ctx.lineTo(points[0].x, points[0].y);

			if (points.length === 2) {
				ctx.lineTo(points[1].x, points[1].y);
			} else {
				// Use cardinal spline for smooth curves
				for (let i = 0; i < points.length - 1; i++) {
					const p0 = points[Math.max(0, i - 1)];
					const p1 = points[i];
					const p2 = points[i + 1];
					const p3 = points[Math.min(points.length - 1, i + 2)];

					const tension = 0.3;
					const cp1x = p1.x + (p2.x - p0.x) * tension;
					const cp1y = p1.y + (p2.y - p0.y) * tension;
					const cp2x = p2.x - (p3.x - p1.x) * tension;
					const cp2y = p2.y - (p3.y - p1.y) * tension;

					ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
				}
			}

			ctx.lineTo(points[points.length - 1].x, h - padding);
			ctx.closePath();
			ctx.fill();
		}

		function toggle() {
			const btn = document.getElementById('toggleBtn');
			const status = document.getElementById('status');

			if (state.running) {
				clearInterval(state.intervalId);
				state.running = false;
				btn.textContent = 'Start';
				btn.classList.remove('stop');
				status.classList.remove('running');
			} else {
				const interval = parseInt(document.getElementById('interval').value);
				ping();
				state.intervalId = setInterval(ping, interval);
				state.running = true;
				btn.textContent = 'Stop';
				btn.classList.add('stop');
				status.classList.add('running');
			}
		}

		function clearData() {
			state.samples = [];
			state.displaySamples = [];
			state.failures = 0;
			state.total = 0;
			['current', 'min', 'max', 'avg', 'jitter'].forEach(id =>
				document.getElementById(id).textContent = '--');
			document.getElementById('loss').textContent = '0%';
			document.getElementById('log').innerHTML = '';
			drawGraph();
		}

		// Tap-to-cycle for select elements (Tesla browser compatibility)
		document.querySelectorAll('select').forEach(select => {
			select.addEventListener('click', function(e) {
				e.preventDefault();
				const options = this.options;
				const currentIndex = this.selectedIndex;
				const nextIndex = (currentIndex + 1) % options.length;
				this.selectedIndex = nextIndex;

				// If interval changes while running, restart with new interval
				if (this.id === 'interval' && state.running) {
					clearInterval(state.intervalId);
					const interval = parseInt(this.value);
					state.intervalId = setInterval(ping, interval);
				}
			});
		});
	</script>
</body>

</html>
