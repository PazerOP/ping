<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Latency Monitor</title>
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
			background: #0a0a0f;
			color: #e0e0e0;
			min-height: 100vh;
			padding: 20px;
			zoom: 1.25;
		}

		.container {
			width: 100%;
			margin: 0 auto;
		}

		h1 {
			font-size: 1.5rem;
			font-weight: 400;
			margin-bottom: 20px;
			color: #8af;
		}

		.stats {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 15px;
			margin-bottom: 20px;
		}

		.stat-box {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			text-align: center;
		}

		.stat-label {
			font-size: 0.75rem;
			color: #888;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			margin-bottom: 5px;
		}

		.stat-value {
			font-size: 1.5rem;
			font-weight: 600;
			font-family: 'SF Mono', Monaco, monospace;
		}

		.stat-value.current {
			color: #4f8;
		}

		.stat-value.min {
			color: #4df;
		}

		.stat-value.max {
			color: #f84;
		}

		.stat-value.avg {
			color: #fa4;
		}

		.stat-value.jitter {
			color: #c8f;
		}

		.stat-value.loss {
			color: #f44;
		}

		.controls {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
			flex-wrap: wrap;
			align-items: center;
		}

		.controls label {
			font-size: 0.85rem;
			color: #888;
		}

		.controls select {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 4px;
			padding: 8px 12px;
			color: #e0e0e0;
			font-size: 0.9rem;
		}

		.controls select:focus {
			outline: none;
			border-color: #4af;
		}

		button {
			background: #2a4;
			border: none;
			border-radius: 4px;
			padding: 8px 20px;
			color: white;
			font-size: 0.9rem;
			cursor: pointer;
			transition: background 0.2s;
		}

		button:hover {
			background: #3b5;
		}

		button.stop {
			background: #a33;
		}

		button.stop:hover {
			background: #c44;
		}

		button.clear {
			background: #555;
		}

		button.clear:hover {
			background: #666;
		}

		.graph-container {
			background: #151520;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 15px;
			margin-bottom: 20px;
		}

		canvas {
			width: 100%;
			height: 200px;
			display: block;
		}

		.log {
			background: #0d0d12;
			border: 1px solid #252535;
			border-radius: 8px;
			padding: 10px;
			max-height: 200px;
			overflow-y: auto;
			font-family: 'SF Mono', Monaco, monospace;
			font-size: 0.8rem;
		}

		.log-entry {
			padding: 3px 0;
			border-bottom: 1px solid #1a1a25;
		}

		.log-entry:last-child {
			border-bottom: none;
		}

		.log-time {
			color: #666;
		}

		.log-ok {
			color: #4f8;
		}

		.log-slow {
			color: #fa4;
		}

		.log-fail {
			color: #f44;
		}

		.status {
			display: inline-block;
			width: 10px;
			height: 10px;
			border-radius: 50%;
			margin-right: 10px;
			background: #444;
		}

		.status.running {
			background: #4f8;
			animation: pulse 1s infinite;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}
		}

		.header {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 20px;
		}

		.header-links {
			margin-left: auto;
			display: flex;
			gap: 15px;
		}

		.header-links a {
			color: #888;
			text-decoration: none;
			font-size: 0.85rem;
			transition: color 0.2s;
		}

		.header-links a:hover {
			color: #8af;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<span class="status" id="status"></span>
			<h1>Latency Monitor</h1>
			<div class="header-links">
				<a href="https://github.com/PazerOP/ping" target="_blank">GitHub</a>
				<a href="https://claude.ai/code" target="_blank">Claude Code</a>
			</div>
		</div>
		<div class="controls">
			<label>Target:</label>
			<select id="target">
				<option value="https://www.google.com/favicon.ico">Google</option>
				<option value="https://www.cloudflare.com/favicon.ico">Cloudflare</option>
				<option value="https://www.amazon.com/favicon.ico">Amazon</option>
				<option value="https://github.githubassets.com/favicons/favicon.svg">GitHub</option>
				<option value="https://www.apple.com/favicon.ico">Apple</option>
			</select>
			<label>Interval:</label>
			<select id="interval">
				<option value="500">500ms</option>
				<option value="1000" selected>1s</option>
				<option value="2000">2s</option>
				<option value="5000">5s</option>
			</select>
			<button id="toggleBtn" onclick="toggle()">Start</button>
			<button class="clear" onclick="clearData()">Clear</button>
		</div>
		<div class="stats">
			<div class="stat-box">
				<div class="stat-label">Current</div>
				<div class="stat-value current" id="current">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Min</div>
				<div class="stat-value min" id="min">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Max</div>
				<div class="stat-value max" id="max">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Avg</div>
				<div class="stat-value avg" id="avg">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Jitter</div>
				<div class="stat-value jitter" id="jitter">--</div>
			</div>
			<div class="stat-box">
				<div class="stat-label">Loss</div>
				<div class="stat-value loss" id="loss">0%</div>
			</div>
		</div>
		<div class="graph-container">
			<canvas id="graph"></canvas>
		</div>
		<div class="log" id="log"></div>
	</div>
	<script>
		const state = {
			running: false,
			intervalId: null,
			samples: [], // Now stores { value: number|null, time: number }
			displayValues: [], // Animated Y values for smooth rendering
			failures: 0,
			total: 0,
			maxSamples: 100,
			animationId: null,
			lastFrameTime: 0,
			startTime: null // Track when monitoring started
		};

		const canvas = document.getElementById('graph');
		const ctx = canvas.getContext('2d');

		// Easing function for smooth animation
		function easeOutCubic(t) {
			return 1 - Math.pow(1 - t, 3);
		}

		// Linear interpolation
		function lerp(start, end, t) {
			return start + (end - start) * t;
		}

		// Animation loop for smooth graph updates
		function animate(currentTime) {
			if (!state.lastFrameTime) state.lastFrameTime = currentTime;
			state.lastFrameTime = currentTime;

			// Animation speed - how fast Y values converge (higher = faster)
			const animationSpeed = 0.15;

			// Build a map of sample time -> display value for Y animation
			const displayMap = new Map();
			state.displayValues.forEach(dv => displayMap.set(dv.time, dv.value));

			// Update display values to match samples
			const newDisplayValues = [];
			for (const sample of state.samples) {
				const existing = displayMap.get(sample.time);
				let displayValue;

				if (sample.value === null) {
					displayValue = null;
				} else if (existing === undefined || existing === null) {
					// New sample - start from previous display value or target
					const prevDisplay = newDisplayValues.length > 0
						? newDisplayValues[newDisplayValues.length - 1].value
						: sample.value;
					displayValue = prevDisplay !== null ? prevDisplay : sample.value;
				} else if (Math.abs(sample.value - existing) > 0.5) {
					// Animate toward target
					displayValue = lerp(existing, sample.value, animationSpeed);
				} else {
					displayValue = sample.value;
				}

				newDisplayValues.push({ time: sample.time, value: displayValue });
			}
			state.displayValues = newDisplayValues;

			// Always redraw since time is always moving (continuous scroll)
			drawGraph();

			state.animationId = requestAnimationFrame(animate);
		}

		// Start animation loop
		state.animationId = requestAnimationFrame(animate);

		function resizeCanvas() {
			const rect = canvas.getBoundingClientRect();
			canvas.width = rect.width * window.devicePixelRatio;
			canvas.height = rect.height * window.devicePixelRatio;
			ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
			drawGraph();
		}

		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		function ping() {
			const url = document.getElementById('target').value;
			const start = performance.now();
			const sampleTime = performance.now();
			state.total++;

			const img = new Image();
			let done = false;

			const timeout = setTimeout(() => {
				if (done) return;
				done = true;
				state.failures++;
				state.samples.push({ value: null, time: sampleTime }); // Record loss with timestamp
				pruneOldSamples();
				updateStats(null);
				addLog(null, false);
			}, 2000);

			function handleResponse() {
				if (done) return;
				done = true;
				clearTimeout(timeout);
				const latency = Math.round(performance.now() - start);
				recordSuccess(latency, sampleTime);
			}

			img.onload = handleResponse;
			img.onerror = handleResponse; // onerror still means network responded

			img.src = url + '?_=' + Date.now() + Math.random();
		}

		function recordSuccess(latency, sampleTime) {
			state.samples.push({ value: latency, time: sampleTime });
			pruneOldSamples();
			updateStats(latency);
			addLog(latency, true);
		}

		// Remove samples that are too old to be visible
		function pruneOldSamples() {
			const now = performance.now();
			const interval = parseInt(document.getElementById('interval').value);
			const windowDuration = (state.maxSamples - 1) * interval;

			// Keep samples within the visible time window plus a small buffer
			while (state.samples.length > 0 && (now - state.samples[0].time) > windowDuration + interval) {
				state.samples.shift();
			}
		}

		function updateStats(latency) {
			if (latency !== null) {
				document.getElementById('current').textContent = latency + 'ms';
			}

			// Extract valid (non-null) values from samples
			const validValues = state.samples.map(s => s.value).filter(v => v !== null);

			if (validValues.length > 0) {
				const min = Math.min(...validValues);
				const max = Math.max(...validValues);
				const avg = Math.round(validValues.reduce((a, b) => a + b, 0) / validValues.length);

				document.getElementById('min').textContent = min + 'ms';
				document.getElementById('max').textContent = max + 'ms';
				document.getElementById('avg').textContent = avg + 'ms';

				if (validValues.length > 1) {
					const variance = validValues.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / validValues.length;
					document.getElementById('jitter').textContent = Math.round(Math.sqrt(variance)) + 'ms';
				}
			}

			const lossPercent = state.total > 0 ? Math.round((state.failures / state.total) * 100) : 0;
			document.getElementById('loss').textContent = lossPercent + '%';
		}

		function addLog(latency, success) {
			const log = document.getElementById('log');
			const time = new Date().toLocaleTimeString();
			const target = document.getElementById('target').selectedOptions[0].text;
			const entry = document.createElement('div');
			entry.className = 'log-entry';

			if (success) {
				const cls = latency < 100 ? 'log-ok' : (latency < 300 ? 'log-slow' : 'log-fail');
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="${cls}">${latency}ms</span>`;
			} else {
				entry.innerHTML = `<span class="log-time">${time}</span> ${target} <span class="log-fail">TIMEOUT</span>`;
			}

			log.insertBefore(entry, log.firstChild);
			while (log.children.length > 50) log.removeChild(log.lastChild);
		}

		function drawGraph() {
			const w = canvas.width / window.devicePixelRatio;
			const h = canvas.height / window.devicePixelRatio;

			ctx.fillStyle = '#151520';
			ctx.fillRect(0, 0, w, h);

			const padding = 10;
			const graphW = w - padding * 2;
			const graphH = h - padding * 2;

			// Grid
			ctx.strokeStyle = '#252535';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = padding + (graphH / 4) * i;
				ctx.beginPath();
				ctx.moveTo(padding, y);
				ctx.lineTo(w - padding, y);
				ctx.stroke();
			}

			if (state.displayValues.length < 2) {
				// Scale labels even when empty
				ctx.fillStyle = '#666';
				ctx.font = '10px monospace';
				ctx.textAlign = 'right';
				ctx.fillText('100ms', w - padding, padding + 10);
				ctx.fillText('0ms', w - padding, h - padding);
				return;
			}

			// Calculate time window for X positioning
			const now = performance.now();
			const interval = parseInt(document.getElementById('interval').value);
			const windowDuration = (state.maxSamples - 1) * interval;

			// Function to get X position from timestamp (continuous time-based)
			function getX(time) {
				const age = now - time;
				// Newest at right edge, oldest at left edge
				const normalizedAge = age / windowDuration;
				return w - padding - normalizedAge * graphW;
			}

			// Filter out nulls for maxVal calculation
			const validValues = state.samples.map(s => s.value).filter(v => v !== null);
			const maxVal = validValues.length > 0 ? Math.max(...validValues, 100) : 100;

			// Build points array with time-based X positions
			let points = [];
			state.displayValues.forEach((sample, i) => {
				const x = getX(sample.time);
				// Only include points within visible area (with small buffer)
				if (x >= padding - 20 && x <= w - padding + 20) {
					if (sample.value !== null) {
						const y = padding + graphH - (sample.value / maxVal) * graphH;
						points.push({ x, y, isNull: false });
					} else {
						points.push({ x, y: h - padding - 10, isNull: true });
					}
				}
			});

			// Separate into segments (break at nulls)
			let segments = [];
			let currentSegment = [];
			points.forEach(pt => {
				if (!pt.isNull) {
					currentSegment.push(pt);
				} else {
					if (currentSegment.length > 0) {
						segments.push(currentSegment);
						currentSegment = [];
					}
				}
			});
			if (currentSegment.length > 0) {
				segments.push(currentSegment);
			}

			// Fill under line for each segment
			ctx.fillStyle = 'rgba(68, 255, 136, 0.1)';
			segments.forEach(seg => {
				if (seg.length >= 2) {
					drawSmoothFill(seg, h, padding);
				}
			});

			// Line for each segment
			ctx.strokeStyle = '#4f8';
			ctx.lineWidth = 2;
			segments.forEach(seg => {
				if (seg.length >= 2) {
					drawSmoothLine(seg);
				}
			});

			// Draw red X marks for packet loss
			ctx.strokeStyle = '#f44';
			ctx.lineWidth = 2;
			state.samples.forEach(sample => {
				if (sample.value === null) {
					const x = getX(sample.time);
					if (x >= padding && x <= w - padding) {
						const y = h - padding - 10;
						ctx.beginPath();
						ctx.moveTo(x - 4, y - 4);
						ctx.lineTo(x + 4, y + 4);
						ctx.moveTo(x + 4, y - 4);
						ctx.lineTo(x - 4, y + 4);
						ctx.stroke();
					}
				}
			});

			// Current point (most recent sample)
			if (state.displayValues.length > 0) {
				const last = state.displayValues[state.displayValues.length - 1];
				const x = getX(last.time);
				if (x >= padding && x <= w - padding) {
					if (last.value !== null) {
						const y = padding + graphH - (last.value / maxVal) * graphH;
						ctx.fillStyle = '#4f8';
						ctx.beginPath();
						ctx.arc(x, y, 5, 0, Math.PI * 2);
						ctx.fill();
					} else {
						ctx.fillStyle = '#f44';
						ctx.beginPath();
						ctx.arc(x, h - padding - 10, 5, 0, Math.PI * 2);
						ctx.fill();
					}
				}
			}

			// Scale labels
			ctx.fillStyle = '#666';
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			ctx.fillText(maxVal + 'ms', w - padding, padding + 10);
			ctx.fillText('0ms', w - padding, h - padding);
		}

		// Draw smooth curved line through points
		function drawSmoothLine(points) {
			if (points.length < 2) return;

			ctx.beginPath();
			ctx.moveTo(points[0].x, points[0].y);

			if (points.length === 2) {
				ctx.lineTo(points[1].x, points[1].y);
			} else {
				// Use cardinal spline for smooth curves
				for (let i = 0; i < points.length - 1; i++) {
					const p0 = points[Math.max(0, i - 1)];
					const p1 = points[i];
					const p2 = points[i + 1];
					const p3 = points[Math.min(points.length - 1, i + 2)];

					// Control points for smooth curve
					const tension = 0.3;
					const cp1x = p1.x + (p2.x - p0.x) * tension;
					const cp1y = p1.y + (p2.y - p0.y) * tension;
					const cp2x = p2.x - (p3.x - p1.x) * tension;
					const cp2y = p2.y - (p3.y - p1.y) * tension;

					ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
				}
			}
			ctx.stroke();
		}

		// Draw smooth filled area under curve
		function drawSmoothFill(points, h, padding) {
			if (points.length < 2) return;

			ctx.beginPath();
			ctx.moveTo(points[0].x, h - padding);
			ctx.lineTo(points[0].x, points[0].y);

			if (points.length === 2) {
				ctx.lineTo(points[1].x, points[1].y);
			} else {
				// Use cardinal spline for smooth curves
				for (let i = 0; i < points.length - 1; i++) {
					const p0 = points[Math.max(0, i - 1)];
					const p1 = points[i];
					const p2 = points[i + 1];
					const p3 = points[Math.min(points.length - 1, i + 2)];

					const tension = 0.3;
					const cp1x = p1.x + (p2.x - p0.x) * tension;
					const cp1y = p1.y + (p2.y - p0.y) * tension;
					const cp2x = p2.x - (p3.x - p1.x) * tension;
					const cp2y = p2.y - (p3.y - p1.y) * tension;

					ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
				}
			}

			ctx.lineTo(points[points.length - 1].x, h - padding);
			ctx.closePath();
			ctx.fill();
		}

		function toggle() {
			const btn = document.getElementById('toggleBtn');
			const status = document.getElementById('status');

			if (state.running) {
				clearInterval(state.intervalId);
				state.running = false;
				btn.textContent = 'Start';
				btn.classList.remove('stop');
				status.classList.remove('running');
			} else {
				const interval = parseInt(document.getElementById('interval').value);
				ping();
				state.intervalId = setInterval(ping, interval);
				state.running = true;
				btn.textContent = 'Stop';
				btn.classList.add('stop');
				status.classList.add('running');
			}
		}

		function clearData() {
			state.samples = [];
			state.displayValues = [];
			state.failures = 0;
			state.total = 0;
			['current', 'min', 'max', 'avg', 'jitter'].forEach(id =>
				document.getElementById(id).textContent = '--');
			document.getElementById('loss').textContent = '0%';
			document.getElementById('log').innerHTML = '';
			drawGraph();
		}

		// Tap-to-cycle for select elements (Tesla browser compatibility)
		document.querySelectorAll('select').forEach(select => {
			select.addEventListener('click', function(e) {
				e.preventDefault();
				const options = this.options;
				const currentIndex = this.selectedIndex;
				const nextIndex = (currentIndex + 1) % options.length;
				this.selectedIndex = nextIndex;

				// If interval changes while running, restart with new interval
				if (this.id === 'interval' && state.running) {
					clearInterval(state.intervalId);
					const interval = parseInt(this.value);
					state.intervalId = setInterval(ping, interval);
				}
			});
		});
	</script>
</body>

</html>
